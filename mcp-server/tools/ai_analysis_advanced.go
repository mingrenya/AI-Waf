// tools/ai_analysis_advanced.go
// 高级AI分析工具 - 攻击模式识别和规则生成
package tools

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// AnalyzeAttackPatternsInput 分析攻击模式的输入参数
type AnalyzeAttackPatternsInput struct {
	TimeRange        string  `json:"timeRange" jsonschema:"时间范围：1h,6h,24h,7d,默认24h"`
	MinSamples       int     `json:"minSamples,omitempty" jsonschema:"最小样本数,默认10"`
	AnomalyThreshold float64 `json:"anomalyThreshold,omitempty" jsonschema:"异常检测阈值,默认2.0"`
	ClusteringMethod string  `json:"clusteringMethod,omitempty" jsonschema:"聚类方法：kmeans,dbscan,默认kmeans"`
}

// AnalyzeAttackPatternsOutput 攻击模式分析输出
type AnalyzeAttackPatternsOutput struct {
	DetectedPatterns    []DetectedPattern   `json:"detectedPatterns" jsonschema:"检测到的攻击模式"`
	TotalSamples        int                 `json:"totalSamples" jsonschema:"分析的样本总数"`
	PatternCount        int                 `json:"patternCount" jsonschema:"识别的模式数量"`
	HighSeverityCount   int                 `json:"highSeverityCount" jsonschema:"高危模式数量"`
	AutoGeneratedRules  int                 `json:"autoGeneratedRules" jsonschema:"自动生成的规则数量"`
	AnalysisMetrics     AnalysisMetrics     `json:"analysisMetrics" jsonschema:"分析指标"`
}

// DetectedPattern 检测到的攻击模式
type DetectedPattern struct {
	ID              string             `json:"id" jsonschema:"模式ID"`
	Name            string             `json:"name" jsonschema:"模式名称"`
	PatternType     string             `json:"patternType" jsonschema:"模式类型：sql_injection,xss,path_traversal等"`
	Confidence      float64            `json:"confidence" jsonschema:"置信度(0-1)"`
	Severity        string             `json:"severity" jsonschema:"严重程度：low,medium,high,critical"`
	SampleCount     int                `json:"sampleCount" jsonschema:"样本数量"`
	Frequency       float64            `json:"frequency" jsonschema:"出现频率(每小时)"`
	Characteristics PatternCharacteristics `json:"characteristics" jsonschema:"模式特征"`
	Recommendation  string             `json:"recommendation" jsonschema:"防护建议"`
}

// PatternCharacteristics 模式特征
type PatternCharacteristics struct {
	CommonURLs      []string          `json:"commonUrls" jsonschema:"常见攻击URL"`
	CommonPaths     []string          `json:"commonPaths" jsonschema:"常见攻击路径"`
	SourceIPCountries []string        `json:"sourceIpCountries" jsonschema:"攻击源国家"`
	PayloadPatterns []string          `json:"payloadPatterns" jsonschema:"有效载荷模式"`
	UserAgents      []string          `json:"userAgents" jsonschema:"User-Agent特征"`
}

// AnalysisMetrics 分析指标
type AnalysisMetrics struct {
	ProcessingTime   float64 `json:"processingTime" jsonschema:"处理时间(秒)"`
	ClusteringScore  float64 `json:"clusteringScore" jsonschema:"聚类质量分数"`
	AnomalyScore     float64 `json:"anomalyScore" jsonschema:"异常检测分数"`
	AccuracyEstimate float64 `json:"accuryEstimate" jsonschema:"准确度估计"`
}

// CreateAnalyzeAttackPatterns 创建分析攻击模式的工具函数
func CreateAnalyzeAttackPatterns(client *APIClient) func(context.Context, *mcp.CallToolRequest, AnalyzeAttackPatternsInput) (*mcp.CallToolResult, AnalyzeAttackPatternsOutput, error) {
	return func(ctx context.Context, req *mcp.CallToolRequest, input AnalyzeAttackPatternsInput) (*mcp.CallToolResult, AnalyzeAttackPatternsOutput, error) {
		logger := NewToolLogger("analyze_attack_patterns")
		logger.LogInput(input)
		
		if input.TimeRange == "" {
			input.TimeRange = "24h"
		}
		if input.MinSamples == 0 {
			input.MinSamples = 10
		}
		if input.AnomalyThreshold == 0 {
			input.AnomalyThreshold = 2.0
		}
		if input.ClusteringMethod == "" {
			input.ClusteringMethod = "kmeans"
		}
		
		// 调用后端AI分析API
		requestData := map[string]interface{}{
			"timeRange":        input.TimeRange,
			"minSamples":       input.MinSamples,
			"anomalyThreshold": input.AnomalyThreshold,
			"clusteringMethod": input.ClusteringMethod,
			"enableAutoRuleGen": true, // 启用自动规则生成
		}
		
		data, err := client.Post("/api/v1/ai-analyzer/analyze/patterns", requestData)
		if err != nil {
			logger.LogError(err)
			return nil, AnalyzeAttackPatternsOutput{}, fmt.Errorf("分析攻击模式失败: %w", err)
		}

		var result struct {
			Data AnalyzeAttackPatternsOutput `json:"data"`
		}
		if err := json.Unmarshal(data, &result); err != nil {
			logger.LogError(err)
			return nil, AnalyzeAttackPatternsOutput{}, fmt.Errorf("解析响应失败: %w", err)
		}

		logger.LogSuccess(fmt.Sprintf("识别到%d个攻击模式，自动生成%d条规则", 
			result.Data.PatternCount, result.Data.AutoGeneratedRules))
		return nil, result.Data, nil
	}
}

// GenerateRuleFromPatternInput 从模式生成规则的输入参数
type GenerateRuleFromPatternInput struct {
	PatternID       string  `json:"patternId" jsonschema:"攻击模式ID"`
	RuleType        string  `json:"ruleType" jsonschema:"规则类型：micro_rule,modsecurity,默认micro_rule"`
	Action          string  `json:"action" jsonschema:"规则动作：block,log,默认block"`
	Priority        int     `json:"priority,omitempty" jsonschema:"优先级,默认100"`
	EnableAutoReview bool   `json:"enableAutoReview,omitempty" jsonschema:"启用自动审核"`
}

// GenerateRuleFromPatternOutput 生成规则输出
type GenerateRuleFromPatternOutput struct {
	RuleID          string             `json:"ruleId" jsonschema:"生成的规则ID"`
	RuleName        string             `json:"ruleName" jsonschema:"规则名称"`
	RuleType        string             `json:"ruleType" jsonschema:"规则类型"`
	RuleContent     interface{}        `json:"ruleContent" jsonschema:"规则内容"`
	Confidence      float64            `json:"confidence" jsonschema:"规则置信度"`
	Status          string             `json:"status" jsonschema:"规则状态：pending,approved,deployed"`
	AutoReviewed    bool               `json:"autoReviewed" jsonschema:"是否自动审核"`
	ReviewResult    string             `json:"reviewResult,omitempty" jsonschema:"审核结果"`
	DeploymentReady bool               `json:"deploymentReady" jsonschema:"是否可部署"`
	Recommendation  RuleRecommendation `json:"recommendation" jsonschema:"规则建议"`
}

// RuleRecommendation 规则建议
type RuleRecommendation struct {
	ShouldDeploy     bool     `json:"shouldDeploy" jsonschema:"是否建议部署"`
	Reason           string   `json:"reason" jsonschema:"建议原因"`
	PotentialImpact  string   `json:"potentialImpact" jsonschema:"潜在影响"`
	TestingSuggestion string  `json:"testingSuggestion" jsonschema:"测试建议"`
	RollbackPlan     string   `json:"rollbackPlan" jsonschema:"回滚计划"`
}

// CreateGenerateRuleFromPattern 创建从模式生成规则的工具函数
func CreateGenerateRuleFromPattern(client *APIClient) func(context.Context, *mcp.CallToolRequest, GenerateRuleFromPatternInput) (*mcp.CallToolResult, GenerateRuleFromPatternOutput, error) {
	return func(ctx context.Context, req *mcp.CallToolRequest, input GenerateRuleFromPatternInput) (*mcp.CallToolResult, GenerateRuleFromPatternOutput, error) {
		logger := NewToolLogger("generate_rule_from_pattern")
		logger.LogInput(input)
		
		if input.RuleType == "" {
			input.RuleType = "micro_rule"
		}
		if input.Action == "" {
			input.Action = "block"
		}
		if input.Priority == 0 {
			input.Priority = 100
		}
		
		requestData := map[string]interface{}{
			"patternId":       input.PatternID,
			"ruleType":        input.RuleType,
			"action":          input.Action,
			"priority":        input.Priority,
			"enableAutoReview": input.EnableAutoReview,
		}
		
		data, err := client.Post("/api/v1/ai-analyzer/generate/rule", requestData)
		if err != nil {
			logger.LogError(err)
			return nil, GenerateRuleFromPatternOutput{}, fmt.Errorf("生成规则失败: %w", err)
		}

		var result struct {
			Data GenerateRuleFromPatternOutput `json:"data"`
		}
		if err := json.Unmarshal(data, &result); err != nil {
			logger.LogError(err)
			return nil, GenerateRuleFromPatternOutput{}, fmt.Errorf("解析响应失败: %w", err)
		}

		logger.LogSuccess(fmt.Sprintf("生成规则成功：%s，状态：%s", result.Data.RuleName, result.Data.Status))
		return nil, result.Data, nil
	}
}

// EvaluateRuleEffectivenessInput 评估规则效果的输入参数
type EvaluateRuleEffectivenessInput struct {
	RuleID    string `json:"ruleId" jsonschema:"规则ID"`
	TimeRange string `json:"timeRange,omitempty" jsonschema:"评估时间范围：1h,6h,24h,7d,默认24h"`
}

// EvaluateRuleEffectivenessOutput 规则效果评估输出
type EvaluateRuleEffectivenessOutput struct {
	RuleID            string             `json:"ruleId" jsonschema:"规则ID"`
	RuleName          string             `json:"ruleName" jsonschema:"规则名称"`
	EvaluationPeriod  string             `json:"evaluationPeriod" jsonschema:"评估周期"`
	EffectivenessScore float64           `json:"effectivenessScore" jsonschema:"效果评分(0-100)"`
	PerformanceMetrics PerformanceMetrics `json:"performanceMetrics" jsonschema:"性能指标"`
	SecurityImpact     SecurityImpact     `json:"securityImpact" jsonschema:"安全影响"`
	FalsePositiveRate  float64           `json:"falsePositiveRate" jsonschema:"误报率(%)"`
	TruePositiveRate   float64           `json:"truePositiveRate" jsonschema:"真阳率(%)"`
	Recommendation     string            `json:"recommendation" jsonschema:"优化建议"`
	AdjustmentSuggestion RuleAdjustment  `json:"adjustmentSuggestion" jsonschema:"调整建议"`
}

// PerformanceMetrics 性能指标
type PerformanceMetrics struct {
	TotalMatches      int     `json:"totalMatches" jsonschema:"总匹配次数"`
	BlockedRequests   int     `json:"blockedRequests" jsonschema:"阻止的请求数"`
	LoggedRequests    int     `json:"loggedRequests" jsonschema:"记录的请求数"`
	AverageMatchTime  float64 `json:"averageMatchTime" jsonschema:"平均匹配时间(ms)"`
	CPUUsage          float64 `json:"cpuUsage" jsonschema:"CPU使用率(%)"`
	MemoryUsage       float64 `json:"memoryUsage" jsonschema:"内存使用(MB)"`
}

// SecurityImpact 安全影响
type SecurityImpact struct {
	AttacksPrevented    int      `json:"attacksPrevented" jsonschema:"阻止的攻击数"`
	AttackTypes         []string `json:"attackTypes" jsonschema:"阻止的攻击类型"`
	TopBlockedIPs       []string `json:"topBlockedIPs" jsonschema:"被阻止最多的IP"`
	RiskReductionScore  float64  `json:"riskReductionScore" jsonschema:"风险降低分数(0-100)"`
	ThreatCoverage      float64  `json:"threatCoverage" jsonschema:"威胁覆盖率(%)"`
}

// RuleAdjustment 规则调整建议
type RuleAdjustment struct {
	ShouldAdjust      bool     `json:"shouldAdjust" jsonschema:"是否需要调整"`
	AdjustmentType    string   `json:"adjustmentType" jsonschema:"调整类型：tighten,relax,disable"`
	SuggestedChanges  []string `json:"suggestedChanges" jsonschema:"建议的修改"`
	ExpectedImprovement string `json:"expectedImprovement" jsonschema:"预期改进"`
}

// CreateEvaluateRuleEffectiveness 创建评估规则效果的工具函数
func CreateEvaluateRuleEffectiveness(client *APIClient) func(context.Context, *mcp.CallToolRequest, EvaluateRuleEffectivenessInput) (*mcp.CallToolResult, EvaluateRuleEffectivenessOutput, error) {
	return func(ctx context.Context, req *mcp.CallToolRequest, input EvaluateRuleEffectivenessInput) (*mcp.CallToolResult, EvaluateRuleEffectivenessOutput, error) {
		logger := NewToolLogger("evaluate_rule_effectiveness")
		logger.LogInput(input)
		
		if input.TimeRange == "" {
			input.TimeRange = "24h"
		}
		
		path := fmt.Sprintf("/api/v1/ai-analyzer/evaluate/rule/%s?timeRange=%s", input.RuleID, input.TimeRange)
		data, err := client.Get(path)
		if err != nil {
			logger.LogError(err)
			return nil, EvaluateRuleEffectivenessOutput{}, fmt.Errorf("评估规则效果失败: %w", err)
		}

		var result struct {
			Data EvaluateRuleEffectivenessOutput `json:"data"`
		}
		if err := json.Unmarshal(data, &result); err != nil {
			logger.LogError(err)
			return nil, EvaluateRuleEffectivenessOutput{}, fmt.Errorf("解析响应失败: %w", err)
		}

		logger.LogSuccess(fmt.Sprintf("规则评估完成：效果评分%.1f，误报率%.2f%%", 
			result.Data.EffectivenessScore, result.Data.FalsePositiveRate))
		return nil, result.Data, nil
	}
}

// OptimizeRuleInput 优化规则的输入参数
type OptimizeRuleInput struct {
	RuleID         string   `json:"ruleId" jsonschema:"规则ID"`
	OptimizeFor    string   `json:"optimizeFor" jsonschema:"优化目标：accuracy,performance,both,默认both"`
	KeepHistory    bool     `json:"keepHistory,omitempty" jsonschema:"保留优化历史"`
}

// OptimizeRuleOutput 规则优化输出
type OptimizeRuleOutput struct {
	OriginalRuleID  string      `json:"originalRuleId" jsonschema:"原始规则ID"`
	OptimizedRuleID string      `json:"optimizedRuleId" jsonschema:"优化后规则ID"`
	Improvements    []string    `json:"improvements" jsonschema:"改进列表"`
	BeforeMetrics   interface{} `json:"beforeMetrics" jsonschema:"优化前指标"`
	AfterMetrics    interface{} `json:"afterMetrics" jsonschema:"优化后指标"`
	RecommendedAction string    `json:"recommendedAction" jsonschema:"推荐操作"`
}

// CreateOptimizeRule 创建优化规则的工具函数
func CreateOptimizeRule(client *APIClient) func(context.Context, *mcp.CallToolRequest, OptimizeRuleInput) (*mcp.CallToolResult, OptimizeRuleOutput, error) {
	return func(ctx context.Context, req *mcp.CallToolRequest, input OptimizeRuleInput) (*mcp.CallToolResult, OptimizeRuleOutput, error) {
		logger := NewToolLogger("optimize_rule")
		logger.LogInput(input)
		
		if input.OptimizeFor == "" {
			input.OptimizeFor = "both"
		}
		
		requestData := map[string]interface{}{
			"ruleId":      input.RuleID,
			"optimizeFor": input.OptimizeFor,
			"keepHistory": input.KeepHistory,
		}
		
		data, err := client.Post("/api/v1/ai-analyzer/optimize/rule", requestData)
		if err != nil {
			logger.LogError(err)
			return nil, OptimizeRuleOutput{}, fmt.Errorf("优化规则失败: %w", err)
		}

		var result struct {
			Data OptimizeRuleOutput `json:"data"`
		}
		if err := json.Unmarshal(data, &result); err != nil {
			logger.LogError(err)
			return nil, OptimizeRuleOutput{}, fmt.Errorf("解析响应失败: %w", err)
		}

		logger.LogSuccess(fmt.Sprintf("规则优化完成，共%d项改进", len(result.Data.Improvements)))
		return nil, result.Data, nil
	}
}

// CompareRulesInput 对比规则的输入参数
type CompareRulesInput struct {
	RuleID1   string `json:"ruleId1" jsonschema:"规则1 ID"`
	RuleID2   string `json:"ruleId2" jsonschema:"规则2 ID"`
	TimeRange string `json:"timeRange,omitempty" jsonschema:"对比时间范围：24h,7d,30d"`
}

// CompareRulesOutput 规则对比输出
type CompareRulesOutput struct {
	Rule1Metrics   interface{} `json:"rule1Metrics" jsonschema:"规则1指标"`
	Rule2Metrics   interface{} `json:"rule2Metrics" jsonschema:"规则2指标"`
	Winner         string      `json:"winner" jsonschema:"表现更好的规则ID"`
	Differences    []string    `json:"differences" jsonschema:"主要差异"`
	Recommendation string      `json:"recommendation" jsonschema:"推荐建议"`
}

// CreateCompareRules 创建对比规则的工具函数
func CreateCompareRules(client *APIClient) func(context.Context, *mcp.CallToolRequest, CompareRulesInput) (*mcp.CallToolResult, CompareRulesOutput, error) {
	return func(ctx context.Context, req *mcp.CallToolRequest, input CompareRulesInput) (*mcp.CallToolResult, CompareRulesOutput, error) {
		logger := NewToolLogger("compare_rules")
		logger.LogInput(input)
		
		if input.TimeRange == "" {
			input.TimeRange = "24h"
		}
		
		path := fmt.Sprintf("/api/v1/ai-analyzer/compare/rules?ruleId1=%s&ruleId2=%s&timeRange=%s", 
			input.RuleID1, input.RuleID2, input.TimeRange)
		data, err := client.Get(path)
		if err != nil {
			logger.LogError(err)
			return nil, CompareRulesOutput{}, fmt.Errorf("对比规则失败: %w", err)
		}

		var result struct {
			Data CompareRulesOutput `json:"data"`
		}
		if err := json.Unmarshal(data, &result); err != nil {
			logger.LogError(err)
			return nil, CompareRulesOutput{}, fmt.Errorf("解析响应失败: %w", err)
		}

		logger.LogSuccess(fmt.Sprintf("规则对比完成，优胜者：%s", result.Data.Winner))
		return nil, result.Data, nil
	}
}
